#!/usr/bin/env node

/**
 * Session Race Condition Exploits
 * Exploits session management and concurrency vulnerabilities
 * 
 * Vulnerabilities Found:
 * - Session State Race Condition (verified-sessions.json)
 * - Database Atomicity Failures
 * - Concurrent Access without Proper Locking
 * - Race Conditions in Session Management
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { performance } = require('perf_hooks');

class SessionRaceConditionExploiter {
  constructor() {
    this.tempDir = './test-concurrency-temp';
    this.testResults = [];
  }

  /**
   * Test Session Race Condition
   * File: bot/src/utils/databaseConcurrencyControl.ts
   */
  testSessionRaceCondition() {
    console.log('‚ö° Testing Session Race Condition Vulnerability');
    
    const sessionFiles = [
      'verification-sessions.json',
      'admin-verifications.json', 
      'verification-history.json'
    ];

    for (const sessionFile of sessionFiles) {
      console.log(`\nüîç Testing race condition on: ${sessionFile}`);
      
      const startTime = performance.now();
      const operations = [];
      
      // Simulate concurrent session operations
      for (let i = 0; i < 50; i++) {
        operations.push(this.simulateConcurrentSessionOperation(sessionFile, i));
      }
      
      Promise.all(operations).then(() => {
        const endTime = performance.now();
        console.log(`‚úÖ Completed 50 concurrent operations in ${endTime - startTime}ms`);
      });
    }
  }

  /**
   * Simulate concurrent session operation
   */
  async simulateConcurrentSessionOperation(filename, operationId) {
    const sessionId = `session_${operationId}_${Date.now()}`;
    const sessionData = {
      sessionId,
      userId: `user_${operationId}`,
      status: 'active',
      timestamp: Date.now(),
      concurrent: true
    };

    try {
      // Simulate the vulnerable database operation without proper locking
      const filePath = path.join(this.tempDir, filename);
      
      // VULNERABLE: No locking mechanism used
      if (!fs.existsSync(filePath)) {
        fs.writeFileSync(filePath, '[]');
      }
      
      const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
      
      // Add session data (vulnerable to race condition)
      data.push(sessionData);
      
      // Simulate processing delay
      await this.delay(Math.random() * 100);
      
      // Write back without atomic operation
      fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
      
      // Log successful operation
      this.testResults.push({
        type: 'session_write',
        file: filename,
        sessionId,
        operationId,
        timestamp: Date.now(),
        success: true
      });
      
    } catch (error) {
      // Log failed operation
      this.testResults.push({
        type: 'session_write',
        file: filename,
        sessionId,
        operationId,
        timestamp: Date.now(),
        success: false,
        error: error.message
      });
    }
  }

  /**
   * Test Database Race Conditions
   */
  testDatabaseRaceConditions() {
    console.log('\nüóÑÔ∏è Testing Database Race Conditions');
    
    const testScenarios = [
      {
        name: 'Concurrent Session Creation',
        operations: 'create',
        count: 20
      },
      {
        name: 'Concurrent Session Updates', 
        operations: 'update',
        count: 20
      },
      {
        name: 'Mixed Concurrent Operations',
        operations: 'mixed',
        count: 30
      }
    ];

    for (const scenario of testScenarios) {
      console.log(`\nüéØ Running scenario: ${scenario.name}`);
      this.runRaceConditionScenario(scenario);
    }
  }

  /**
   * Run race condition test scenario
   */
  runRaceConditionScenario(scenario) {
    const startTime = performance.now();
    const promises = [];
    
    for (let i = 0; i < scenario.count; i++) {
      const operation = scenario.operations === 'mixed' 
        ? (i % 2 === 0 ? 'create' : 'update')
        : scenario.operations;
      
      promises.push(this.simulateDatabaseOperation(operation, i, scenario));
    }
    
    Promise.allSettled(promises).then(() => {
      const endTime = performance.now();
      const failedOperations = this.testResults.filter(r => !r.success).length;
      
      console.log(`‚è±Ô∏è  Scenario completed in ${endTime - startTime}ms`);
      console.log(`‚ùå Failed operations: ${failedOperations}/${scenario.count}`);
      
      if (failedOperations > 0) {
        console.log('üö® RACE CONDITION VULNERABILITY DETECTED');
        this.analyzeRaceConditionFailures();
      }
    });
  }

  /**
   * Simulate database operation
   */
  async simulateDatabaseOperation(operation, id, scenario) {
    const filePath = path.join(this.tempDir, `race_test_${scenario.name.replace(/\s+/g, '_')}.json`);
    
    try {
      // VULNERABLE: No proper locking or atomic operations
      if (operation === 'create') {
        const sessionData = {
          id: id,
          operation: 'create',
          timestamp: Date.now(),
          data: crypto.randomBytes(16).toString('hex')
        };
        
        let data = [];
        if (fs.existsSync(filePath)) {
          data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
        }
        
        // Race condition: Multiple processes might read same initial state
        data.push(sessionData);
        fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
        
      } else if (operation === 'update') {
        if (fs.existsSync(filePath)) {
          const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
          
          // Race condition: Might update stale data
          if (data.length > 0) {
            data[0].lastUpdate = Date.now();
            data[0].updateCount = (data[0].updateCount || 0) + 1;
            fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
          }
        }
      }
      
      this.testResults.push({
        operation,
        id,
        scenario: scenario.name,
        success: true,
        timestamp: Date.now()
      });
      
    } catch (error) {
      this.testResults.push({
        operation,
        id,
        scenario: scenario.name,
        success: false,
        error: error.message,
        timestamp: Date.now()
      });
    }
  }

  /**
   * Test Session State Corruption
   */
  testSessionStateCorruption() {
    console.log('\nüí• Testing Session State Corruption');
    
    const corruptionScenarios = [
      {
        name: 'Rapid Session Creation/Deletion',
        operation: 'create_delete_rapid',
        iterations: 100
      },
      {
        name: 'Concurrent Session Reading',
        operation: 'read_concurrent', 
        iterations: 50
      },
      {
        name: 'Session State Conflicts',
        operation: 'state_conflict',
        iterations: 30
      }
    ];

    for (const scenario of corruptionScenarios) {
      console.log(`\nüî¨ Testing: ${scenario.name}`);
      this.runCorruptionScenario(scenario);
    }
  }

  /**
   * Run corruption test scenario
   */
  runCorruptionScenario(scenario) {
    const operations = [];
    
    for (let i = 0; i < scenario.iterations; i++) {
      operations.push(this.executeCorruptionOperation(scenario, i));
    }
    
    Promise.allSettled(operations).then(() => {
      this.analyzeCorruptionResults(scenario);
    });
  }

  /**
   * Execute corruption operation
   */
  async executeCorruptionOperation(scenario, iteration) {
    const sessionId = `corrupt_${scenario.name}_${iteration}`;
    const filePath = path.join(this.tempDir, `corruption_${sessionId}.json`);

    try {
      switch (scenario.operation) {
        case 'create_delete_rapid':
          // Rapidly create and delete sessions
          fs.writeFileSync(filePath, JSON.stringify({
            sessionId,
            created: Date.now(),
            status: 'active'
          }, null, 2));
          
          await this.delay(Math.random() * 10); // Very short delay
          
          // Try to read while other operations might be running
          const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
          data.status = 'updated';
          data.updated = Date.now();
          
          await this.delay(Math.random() * 10);
          fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
          
          // Rapid deletion
          await this.delay(Math.random() * 5);
          fs.unlinkSync(filePath);
          break;
          
        case 'read_concurrent':
          // Multiple processes read the same file simultaneously
          if (fs.existsSync(filePath)) {
            const readCount = 0;
            for (let i = 0; i < 10; i++) {
              try {
                JSON.parse(fs.readFileSync(filePath, 'utf8'));
                readCount++;
              } catch (e) {
                // File might be corrupted or deleted during read
              }
              await this.delay(Math.random() * 5);
            }
          }
          break;
          
        case 'state_conflict':
          // Simulate conflicting state updates
          const conflictingData = {
            sessionId,
            status: Math.random() > 0.5 ? 'active' : 'inactive',
            priority: Math.random() * 100,
            timestamp: Date.now()
          };
          
          fs.writeFileSync(filePath, JSON.stringify(conflictingData, null, 2));
          await this.delay(Math.random() * 20);
          
          // Another operation updates the same session
          const updatedData = {
            ...conflictingData,
            status: Math.random() > 0.5 ? 'suspended' : 'active',
            lastUpdate: Date.now()
          };
          
          fs.writeFileSync(filePath, JSON.stringify(updatedData, null, 2));
          break;
      }
      
    } catch (error) {
      console.log(`‚ö†Ô∏è  Corruption operation failed: ${error.message}`);
    }
  }

  /**
   * Analyze race condition failures
   */
  analyzeRaceConditionFailures() {
    const failures = this.testResults.filter(r => !r.success);
    const errorTypes = failures.reduce((acc, failure) => {
      acc[failure.error] = (acc[failure.error] || 0) + 1;
      return acc;
    }, {});

    console.log('üîç Race Condition Analysis:');
    console.log(`Total failures: ${failures.length}`);
    console.log('Error types:');
    
    for (const [error, count] of Object.entries(errorTypes)) {
      console.log(`  - ${error}: ${count} occurrences`);
    }
    
    console.log('\nüö® RECOMMENDED FIXES:');
    console.log('1. Implement proper file locking mechanisms');
    console.log('2. Use atomic write operations');
    console.log('3. Add session state validation');
    console.log('4. Implement retry mechanisms for conflicting operations');
  }

  /**
   * Analyze corruption results
   */
  analyzeCorruptionResults(scenario) {
    console.log(`üìä Corruption test completed for: ${scenario.name}`);
    
    // Check for any corrupted or inconsistent state files
    const tempFiles = fs.readdirSync(this.tempDir).filter(f => f.includes('corruption_'));
    console.log(`üìÅ Remaining files: ${tempFiles.length}`);
    
    for (const file of tempFiles) {
      try {
        const content = fs.readFileSync(path.join(this.tempDir, file), 'utf8');
        JSON.parse(content); // Test if JSON is valid
      } catch (e) {
        console.log(`üö® Corrupted file found: ${file}`);
      }
    }
  }

  /**
   * Utility delay function
   */
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Generate exploit documentation
   */
  generateExploitDocumentation() {
    const doc = `
# Session Race Condition Exploit Documentation

## Vulnerability Summary
Multiple race condition vulnerabilities found in session management and database operations.

## Affected Components
- bot/src/utils/databaseConcurrencyControl.ts
- backend/src/database/jsonDriver.ts
- shared verification session files

## Exploitation Techniques

### 1. Concurrent Session Creation
\`\`\`javascript
// Attack: Create multiple sessions simultaneously
const promises = [];
for (let i = 0; i < 50; i++) {
  promises.push(createSession(\`user_\${i}\`));
}
await Promise.all(promises);
\`\`\`

### 2. Session State Corruption
\`\`\`javascript
// Attack: Rapid read/write operations
for (let i = 0; i < 100; i++) {
  readSession(sessionId);
  updateSession(sessionId, { corrupt: true });
  deleteSession(sessionId);
}
\`\`\`

### 3. Database Atomicity Bypass
\`\`\`javascript
// Attack: Skip locking mechanisms
const session = readSessionUnlocked(sessionId);
modifySession(session);
writeSessionUnlocked(sessionId, session);
\`\`\`

## Impact
- Session state corruption
- Sybil attacks (duplicate sessions)
- Data loss
- Authentication bypass

## Remediation
1. Implement proper file locking
2. Use database transactions
3. Add session validation
4. Implement retry mechanisms
`;

    return doc;
  }

  /**
   * Run all tests
   */
  async runAllTests() {
    console.log('üöÄ Starting Session Race Condition Vulnerability Tests\n');
    
    // Create temp directory
    if (!fs.existsSync(this.tempDir)) {
      fs.mkdirSync(this.tempDir, { recursive: true });
    }

    try {
      this.testSessionRaceCondition();
      this.testDatabaseRaceConditions();
      this.testSessionStateCorruption();
      
      console.log('\nüìã Session Race Condition Exploit Documentation:');
      console.log(this.generateExploitDocumentation());
      
    } finally {
      // Cleanup temp directory
      try {
        fs.rmSync(this.tempDir, { recursive: true, force: true });
      } catch (e) {
        console.log('‚ö†Ô∏è  Could not cleanup temp directory');
      }
    }
  }
}

// CLI usage
if (require.main === module) {
  const exploiter = new SessionRaceConditionExploiter();
  exploiter.runAllTests().catch(console.error);
}

module.exports = SessionRaceConditionExploiter;